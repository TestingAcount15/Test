local replicatedStorage = game:GetService("ReplicatedStorage")
local commonModules = replicatedStorage:WaitForChild("CommonModules")
local taskDefinitionModules = commonModules:WaitForChild("DefinitionModules"):WaitForChild("Task"):WaitForChild("DefinitionModules")

local gettingStarted = taskDefinitionModules:FindFirstChild("Getting Started")
if gettingStarted then
    gettingStarted.Name = "GettingStarted"
else
end

wait("1")

local sections = {
    Quest = "CommonModules.DefinitionModules.Task.DefinitionModules.GettingStarted"
}

local knownQuests = {
    Quest = {
"Cobalt Forge III",
"Economic Growth",
"Farming Frenzy I",
"Island Expansion",
"Collecting Flowers",
"Gold Forge III",
"Forest Danger",
"A Day for Clay",
"Gold Forge II",
"Copper Forge III",
"Copper Forge I",
"Cobalt Forge II",
"Rising entrepreneur",
"Iron Forge II",
"Cobalt Forge I",
"Carrot Patch",
"The adventure begins",
"Iron Forge I",
"Woodland Wanderer",
"Dark Hollow",
"Iron Forge III",
"Mining Frenzy I",
"The Underlings",
"Gold Forge I",
"Copper Forge II",
"Greenhorn",
"Lumberjack I",
"Colored Clay",
"First Steps into the Depths",
"Stone Cold"
    }
}


local function getObjectByPath(root, path)
    local current = root
    for segment in string.gmatch(path, "[^.]+") do
        current = current:FindFirstChild(segment)
        if not current then
            warn("Could not find: " .. segment .. " in path: " .. path)
            return nil
        end
    end
    return current
end

local function detectNewFolders(root, knownFolders)
    local newFolders = {}
    for _, folder in ipairs(root:GetChildren()) do
        if folder:IsA("Folder") and not knownFolders[folder.Name] then
            newFolders[folder.Name] = true
        end
    end
    return newFolders
end

local clipboardOutput = ""
local newQuestsOutput = ""
local newQuestsFound = false
local newFoldersOutput = ""
local knownFolders = {}

for sectionName, path in pairs(sections) do
    local section = getObjectByPath(replicatedStorage, path)
    local knownQuestsSet = {}
    local newQuests = {}
    local newFolders = {}

    if knownQuests[sectionName] then
        for _, QuestName in ipairs(knownQuests[sectionName]) do
            knownQuestsSet[QuestName] = true
        end
    end
    
    if section then
        clipboardOutput = clipboardOutput .. "----- " .. sectionName .. " -----\n"
        local hasModules = false
        
        for _, moduleScript in pairs(section:GetChildren()) do
            if moduleScript:IsA("ModuleScript") then
                local moduleName = moduleScript.Name
                clipboardOutput = clipboardOutput .. moduleName .. "\n"
                hasModules = true
                
                if not knownQuestsSet[moduleName] then
                    newQuests[moduleName] = true
                    newQuestsFound = true
                end
            end
        end
        
        if not hasModules then
            clipboardOutput = clipboardOutput .. "No ModuleScripts found in " .. sectionName .. "\n"
        end

        newFolders = detectNewFolders(section, knownFolders)
        if next(newFolders) then
            newFoldersOutput = newFoldersOutput .. "----- New Folders in " .. sectionName .. " -----\n"
            for folderName in pairs(newFolders) do
                newFoldersOutput = newFoldersOutput .. folderName .. "\n"
            end
        end
    end
    
    if next(newQuests) then
        newQuestsOutput = newQuestsOutput .. "----- New Quests in " .. sectionName .. " -----\n"
        for QuestName in pairs(newQuests) do
            newQuestsOutput = newQuestsOutput .. QuestName .. "\n"
        end
    end
end

local url = "https://discord.com/api/webhooks/1286237119311904812/OmgiYH1xj8E7flMblohaQi2IhED_77E83Ox6sBZRinvNJGbrcFqM8YriPs6Hw5hYpeu9"
local data = {
    ['embeds'] = {}
}

local output = clipboardOutput .. "\n" .. (newQuestsFound and newQuestsOutput or "No new Quests found.") .. "\n" .. newFoldersOutput
local messages = {}

local embedColor = 16744575 
local maxDescriptionLength = 4000

while #output > 0 do
    local chunk = output:sub(1, maxDescriptionLength)
    table.insert(messages, chunk)
    output = output:sub(maxDescriptionLength + 1)
end

local embed = {
    ['title'] = "Quest List",
    ['color'] = embedColor,
    ['footer'] = {
        ['text'] = "Generated by the very best High Realms Player!"  
    }
}

for i, message in ipairs(messages) do
    if i > 1 then
        local newEmbed = table.clone(embed)
        newEmbed['description'] = message
        table.insert(data['embeds'], newEmbed)

        if #data['embeds'] == 10 then
            local jsonData = game:GetService("HttpService"):JSONEncode(data)

            local response = request({
                Url = url,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = jsonData
            })

            if response.Success then
                print("Message " .. tostring(i) .. " sent to Discord webhook!")
            else
                print("Error sending message " .. tostring(i) .. " to Discord webhook:")
                print(response.StatusCode)
                print(response.StatusMessage)
                print(response.Body)
            end

            data['embeds'] = {}
        end
    else
        embed['description'] = message
        table.insert(data['embeds'], embed)
    end
end

if #data['embeds'] > 0 then
    local jsonData = game:GetService("HttpService"):JSONEncode(data)

    local response = request({
        Url = url,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = jsonData
    })

    if response.Success then
    else
        print("Error sending final message to Discord webhook:")
        print(response.StatusCode)
        print(response.StatusMessage)
        print(response.Body)
    end
end
